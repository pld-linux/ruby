diff -ur ruby-1.8.6/ext/thread/thread.c ruby/ext/thread/thread.c
--- ruby-1.8.6/ext/thread/thread.c	2007-03-03 03:08:06.000000000 -0700
+++ ruby/ext/thread/thread.c	2007-03-20 16:26:18.000000000 -0600
@@ -163,13 +163,18 @@
 remove_one(List *list, VALUE value)
 {
     Entry **ref;
+    Entry *prev;
     Entry *entry;
 
-    for (ref = &list->entries, entry = list->entries;
+    for (ref = &list->entries, prev = NULL, entry = list->entries;
               entry != NULL;
-              ref = &entry->next, entry = entry->next) {
+              ref = &entry->next, prev = entry, entry = entry->next) {
         if (entry->value == value) {
             *ref = entry->next;
+            list->size--;
+            if (!entry->next) {
+                list->last_entry = prev;
+            }
             recycle_entries(list, entry, entry);
             break;
         }
@@ -390,7 +395,7 @@
  *
  */
 
-static void
+static VALUE
 lock_mutex(Mutex *mutex)
 {
     VALUE current;
@@ -405,6 +410,7 @@
     mutex->owner = current; 
 
     rb_thread_critical = 0;
+    return Qnil;
 }
 
 static VALUE
@@ -429,8 +435,13 @@
     VALUE waking;
 
     if (!RTEST(mutex->owner)) {
-        return Qundef;
+	rb_raise(rb_eThreadError, "not owner");
     }
+
+    if (mutex->owner != rb_thread_current()) {
+	rb_raise(rb_eThreadError, "not owner");
+    }
+
     mutex->owner = Qnil;
     waking = wake_one(&mutex->waiting);
 
@@ -623,18 +634,12 @@
 wait_condvar(ConditionVariable *condvar, Mutex *mutex)
 {
     rb_thread_critical = 1;
-    if (!RTEST(mutex->owner)) {
-        rb_thread_critical = 0;
-        return;
-    }
-    if (mutex->owner != rb_thread_current()) {
+    if (rb_thread_current() != mutex->owner) {
         rb_thread_critical = 0;
-        rb_raise(rb_eThreadError, "Not owner");
+        rb_raise(rb_eThreadError, "not owner of the synchronization mutex");
     }
-    mutex->owner = Qnil;
-    wait_list(&condvar->waiting);
-
-    lock_mutex(mutex);
+    unlock_mutex_inner(mutex);
+    rb_ensure(wait_list, (VALUE)&condvar->waiting, lock_mutex, (VALUE)mutex);
 }
 
 static VALUE
